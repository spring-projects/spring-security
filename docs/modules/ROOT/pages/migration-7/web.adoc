= Web Migrations

== Favor Relative URIs

When redirecting to a login endpoint, Spring Security has favored absolute URIs in the past.
For example, if you set your login page like so:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
http
    // ...
    .formLogin((form) -> form.loginPage("/my-login"))
    // ...
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
http {
    formLogin {
        loginPage = "/my-login"
    }
}
----

Xml::
+
[source,kotlin,role="secondary"]
----
<http ...>
    <form-login login-page="/my-login"/>
</http>
----
======

then when redirecting to `/my-login` Spring Security would use a `Location:` like the following:

[source]
----
302 Found
// ...
Location: https://myapp.example.org/my-login
----

However, this is no longer necessary given that the RFC is was based on is now obsolete.

In Spring Security 7, this is changed to use a relative URI like so:

[source]
----
302 Found
// ...
Location: /my-login
----

Most applications will not notice a difference.
However, in the event that this change causes problems, you can switch back to the Spring Security 6 behavior by setting the `favorRelativeUrls` value:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
LoginUrlAuthenticationEntryPoint entryPoint = new LoginUrlAuthenticationEntryPoint("/my-login");
entryPoint.setFavorRelativeUris(false);
http
    // ...
    .exceptionHandling((exceptions) -> exceptions.authenticaitonEntryPoint(entryPoint))
    // ...
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
LoginUrlAuthenticationEntryPoint entryPoint = LoginUrlAuthenticationEntryPoint("/my-login")
entryPoint.setFavorRelativeUris(false)

http {
    exceptionHandling {
        authenticationEntryPoint = entryPoint
    }
}
----

Xml::
+
[source,kotlin,role="secondary"]
----
<http entry-point-ref="myEntryPoint">
    <!-- ... -->
</http>

<b:bean id="myEntryPoint" class="org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint">
    <b:property name="favorRelativeUris" value="true"/>
</b:bean>
----
======

== Include the Servlet Path Prefix in Authorization Rules

As of Spring Security 7, `AntPathRequestMatcher` and `MvcRequestMatcher` are no longer supported and the Java DSL requires that all URIs be absolute (less any context root).

For many applications this will make no difference since most commonly all URIs listed are matched by the default servlet.

However, if you have other servlets with servlet path prefixes, xref:servlet/authorization/authorize-http-requests.adoc[then these paths need to be supplied separately].

For example, if I have a Spring MVC controller with `@RequestMapping("/orders")` and my MVC application is deployed to `/mvc` (instead of the default servlet), then the URI for this endpoint is `/mvc/orders`.
Historically, the Java DSL hasn't had a simple way to specify the servlet path prefix and Spring Security attempted to infer it.

Over time, we learned that these inference would surprise developers.
Instead of taking this responsibility away from developers, now it is simpler to specify the servlet path prefix like so:

[method,java]
----
PathPatternRequestParser.Builder servlet = PathPatternRequestParser.servletPath("/mvc");
http
    .authorizeHttpRequests((authorize) -> authorize
        .requestMatchers(servlet.pattern("/orders/**").matcher()).authenticated()
    )
----


For paths that belong to the default servlet, use `PathPatternRequestParser.path()` instead:

[method,java]
----
PathPatternRequestParser.Builder request = PathPatternRequestParser.path();
http
    .authorizeHttpRequests((authorize) -> authorize
        .requestMatchers(request.pattern("/js/**").matcher()).authenticated()
    )
----

Note that this doesn't address every kind of servlet since not all servlets have a path prefix.
For example, expressions that match the JSP Servlet might use an ant pattern `/**/*.jsp`.

There is not yet a general-purpose replacement for these, and so you are encouraged to use `RegexRequestMatcher`, like so:  `regexMatcher("\\.jsp$")`.
