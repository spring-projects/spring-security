= Servlet Architecture Overview

Spring Securityâ€™s servlet support relies on the servlet `Filter` API.
This means that it can work with any application that runs in a servlet container.
It does not require that you use Spring in any other part of your application.

// FIXME: This might be a primer to describe in summary some of the external items (servlet container, spring's ApplicationContext being initialized, etc)

== Understanding the Servlet Filter API

Spring Security's servlet container support (whether you run in Tomcat or other Servlet container) is built on top of the `Filter` API.
This is done because the `Filter` API is a standard that allows injecting logic into an application in any Servlet container.

Since Spring Security is built on top of `Filter` objects, you should know how Servlet `Filter` objects work.

The following example shows a simple `Filter` implementation:

.SimpleFilter Example
====
[source,java]
----
public class SimpleFilter implements Filter {

	public void init(FilterConfig filterConfig)
			throws ServletException {
			// optional initialization
	}

	// invoked every request the Filter is mapped for
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		System.out.println("Before"); // <1>
		chain.doFilter(request, response); // <2>
		System.out.println("After"); // <3>
	}

	public void destroy() {
		// optional cleanup
	}
}
----
<1> Happens before the application is invoked.
<2> Invokes the rest of the application. This could be additional `Filter` objects, a `Servlet`, or both.
<3> Happens after the application is invoked
====

IMPORTANT: If `chain.doFilter` is never invoked, neither is the rest of the application.

A Servlet `Filter` lets us apply logic around the rest of the application.
This means that we can perform logic before, conditionally invoke the rest of the application, and perform logic afterwards in any servlet container.

== Registering a Servlet Filter

In order for a servlet `Filter` to be invoked, it must be registered with the Servlet container.

The following example shows how to do so in XML:

.web.xml
====
[source,xml]
----
<!--1-->
<filter>
	<filter-name>simpleFilter</filter-name>
	<filter-class>sample.SimpleFilter</filter-class>
</filter>

<!--2-->
<filter-mapping>
	<filter-name>simpleFilter</filter-name>
	<url-pattern>/*</url-pattern>
</filter-mapping>
----
<1> Define the `Filter` to be mapped
<2> Provide one or more mappings for the `Filter`.
In this case, `simpleFilter` is mapped by using the `/*` pattern, which signifies that it should be mapped for every request.
====

In Java configuration, you can use a `ServletContextListener`.
The following example shows how to do so:

.RegisterServletContextListener.java
====
[source,java]
----
@WebListener
public class FilterStartupListener
		implements ServletContextListener {

	@Override
	public void contextInitialized(ServletContextEvent sce) {
		ServletContext ctx = sce.getServletContext();

		// <1>
		FilterRegistration fltrReg = ctx.addFilter("simpleFilter", SimpleFilter.class);

		// <2>
		EnumSet<DispatcherType> dispatchers =
			EnumSet.of(DispatcherType.REQUEST);
		// <3>
		boolean isMatchAfter = true;
		// <4>
		fltrReg.addMappingsForUrlPatterns(dispatchers, isMatchAfter, "/*");
	}
}
----
<1> Define the `Filter` to be mapped.
<2> In Java configuration, we must explicitly provide the <<Dispatch Types>>.
<3> In Java configuration, we must explicitly indicate whether the `Filter` should be before or after already registered `Filter` objects.
<4> Provide one more mapping for the Filter.
In this case, `simpleFilter` is mapped by using the `/*` pattern, which signifies that it should be mapped for every request.
====

== Dispatch Types

== Filter Ordering

== Using `DelegatingFilterProxy`

At the heart of integrating Spring with a servlet `Filter` is the `DelegatingFilterProxy`.
The `DelegatingFilterProxy` is registered directly with the servlet container, and it delegates all work to a Spring Bean that implements `Filter`.
